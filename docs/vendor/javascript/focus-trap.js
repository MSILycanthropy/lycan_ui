// focus-trap@7.6.4 downloaded from https://ga.jspm.io/npm:focus-trap@7.6.4/dist/focus-trap.esm.js

import{isFocusable as e,tabbable as t,focusable as a,isTabbable as r,getTabIndex as n}from"tabbable";
/*!
* focus-trap 7.6.4
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/function _arrayLikeToArray(e,t){(null==t||t>e.length)&&(t=e.length);for(var a=0,r=Array(t);a<t;a++)r[a]=e[a];return r}function _arrayWithoutHoles(e){if(Array.isArray(e))return _arrayLikeToArray(e)}function _defineProperty(e,t,a){return(t=_toPropertyKey(t))in e?Object.defineProperty(e,t,{value:a,enumerable:true,configurable:true,writable:true}):e[t]=a,e}function _iterableToArray(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function ownKeys(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function _objectSpread2(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?ownKeys(Object(a),true).forEach((function(t){_defineProperty(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):ownKeys(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function _toConsumableArray(e){return _arrayWithoutHoles(e)||_iterableToArray(e)||_unsupportedIterableToArray(e)||_nonIterableSpread()}function _toPrimitive(e,t){if("object"!=typeof e||!e)return e;var a=e[Symbol.toPrimitive];if(void 0!==a){var r=a.call(e,t||"default");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}function _toPropertyKey(e){var t=_toPrimitive(e,"string");return"symbol"==typeof t?t:t+""}function _unsupportedIterableToArray(e,t){if(e){if("string"==typeof e)return _arrayLikeToArray(e,t);var a={}.toString.call(e).slice(8,-1);return"Object"===a&&e.constructor&&(a=e.constructor.name),"Map"===a||"Set"===a?Array.from(e):"Arguments"===a||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)?_arrayLikeToArray(e,t):void 0}}var o={activateTrap:function activateTrap(e,t){if(e.length>0){var a=e[e.length-1];a!==t&&a._setPausedState(true)}var r=e.indexOf(t);if(r===-1)e.push(t);else{e.splice(r,1);e.push(t)}},deactivateTrap:function deactivateTrap(e,t){var a=e.indexOf(t);a!==-1&&e.splice(a,1);e.length>0&&!e[e.length-1]._isManuallyPaused()&&e[e.length-1]._setPausedState(false)}};var i=function isSelectableInput(e){return e.tagName&&e.tagName.toLowerCase()==="input"&&typeof e.select==="function"};var u=function isEscapeEvent(e){return(e===null||e===void 0?void 0:e.key)==="Escape"||(e===null||e===void 0?void 0:e.key)==="Esc"||(e===null||e===void 0?void 0:e.keyCode)===27};var s=function isTabEvent(e){return(e===null||e===void 0?void 0:e.key)==="Tab"||(e===null||e===void 0?void 0:e.keyCode)===9};var c=function isKeyForward(e){return s(e)&&!e.shiftKey};var l=function isKeyBackward(e){return s(e)&&e.shiftKey};var v=function delay(e){return setTimeout(e,0)};
/**
 * Get an option's value when it could be a plain value, or a handler that provides
 *  the value.
 * @param {*} value Option's value to check.
 * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.
 * @returns {*} The `value`, or the handler's returned value.
 */var d=function valueOrHandler(e){for(var t=arguments.length,a=new Array(t>1?t-1:0),r=1;r<t;r++)a[r-1]=arguments[r];return typeof e==="function"?e.apply(void 0,a):e};var f=function getActualTarget(e){return e.target.shadowRoot&&typeof e.composedPath==="function"?e.composedPath()[0]:e.target};var b=[];var p=function createFocusTrap(p,y){var m=(y===null||y===void 0?void 0:y.document)||document;var h=(y===null||y===void 0?void 0:y.trapStack)||b;var w=_objectSpread2({returnFocusOnDeactivate:true,escapeDeactivates:true,delayInitialFocus:true,isKeyForward:c,isKeyBackward:l},y);var g={containers:[],containerGroups:[],tabbableGroups:[],nodeFocusedBeforeActivation:null,mostRecentlyFocusedNode:null,active:false,paused:false,manuallyPaused:false,delayInitialFocusTimer:void 0,recentNavEvent:void 0};var N;
/**
   * Gets a configuration option value.
   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,
   *  value will be taken from this object. Otherwise, value will be taken from base configuration.
   * @param {string} optionName Name of the option whose value is sought.
   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`
   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.
   */var T=function getOption(e,t,a){return e&&e[t]!==void 0?e[t]:w[a||t]};
/**
   * Finds the index of the container that contains the element.
   * @param {HTMLElement} element
   * @param {Event} [event] If available, and `element` isn't directly found in any container,
   *  the event's composed path is used to see if includes any known trap containers in the
   *  case where the element is inside a Shadow DOM.
   * @returns {number} Index of the container in either `state.containers` or
   *  `state.containerGroups` (the order/length of these lists are the same); -1
   *  if the element isn't found.
   */var F=function findContainerIndex(e,t){var a=typeof(t===null||t===void 0?void 0:t.composedPath)==="function"?t.composedPath():void 0;return g.containerGroups.findIndex((function(t){var r=t.container,n=t.tabbableNodes;return r.contains(e)||(a===null||a===void 0?void 0:a.includes(r))||n.find((function(t){return t===e}))}))};
/**
   * Gets the node for the given option, which is expected to be an option that
   *  can be either a DOM node, a string that is a selector to get a node, `false`
   *  (if a node is explicitly NOT given), or a function that returns any of these
   *  values.
   * @param {string} optionName
   * @param {Object} options
   * @param {boolean} [options.hasFallback] True if the option could be a selector string
   *  and the option allows for a fallback scenario in the case where the selector is
   *  valid but does not match a node (i.e. the queried node doesn't exist in the DOM).
   * @param {Array} [options.params] Params to pass to the option if it's a function.
   * @returns {undefined | null | false | HTMLElement | SVGElement} Returns
   *  `undefined` if the option is not specified; `null` if the option didn't resolve
   *  to a node but `options.hasFallback=true`, `false` if the option resolved to `false`
   *  (node explicitly not given); otherwise, the resolved DOM node.
   * @throws {Error} If the option is set, not `false`, and is not, or does not
   *  resolve to a node, unless the option is a selector string and `options.hasFallback=true`.
   */var k=function getNodeForOption(e){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},a=t.hasFallback,r=a!==void 0&&a,n=t.params,o=n===void 0?[]:n;var i=w[e];typeof i==="function"&&(i=i.apply(void 0,_toConsumableArray(o)));i===true&&(i=void 0);if(!i){if(i===void 0||i===false)return i;throw new Error("`".concat(e,"` was specified but was not a node, or did not return a node"))}var u=i;if(typeof i==="string"){try{u=m.querySelector(i)}catch(t){throw new Error("`".concat(e,'` appears to be an invalid selector; error="').concat(t.message,'"'))}if(!u&&!r)throw new Error("`".concat(e,"` as selector refers to no known node"))}return u};var O=function getInitialFocusNode(){var t=k("initialFocus",{hasFallback:true});if(t===false)return false;if(t===void 0||t&&!e(t,w.tabbableOptions))if(F(m.activeElement)>=0)t=m.activeElement;else{var a=g.tabbableGroups[0];var r=a&&a.firstTabbableNode;t=r||k("fallbackFocus")}else t===null&&(t=k("fallbackFocus"));if(!t)throw new Error("Your focus-trap needs to have at least one focusable element");return t};var P=function updateTabbableNodes(){g.containerGroups=g.containers.map((function(e){var o=t(e,w.tabbableOptions);var i=a(e,w.tabbableOptions);var u=o.length>0?o[0]:void 0;var s=o.length>0?o[o.length-1]:void 0;var c=i.find((function(e){return r(e)}));var l=i.slice().reverse().find((function(e){return r(e)}));var v=!!o.find((function(e){return n(e)>0}));return{container:e,tabbableNodes:o,focusableNodes:i,posTabIndexesFound:v,firstTabbableNode:u,lastTabbableNode:s,firstDomTabbableNode:c,lastDomTabbableNode:l,
/**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
nextTabbableNode:function nextTabbableNode(e){var t=!(arguments.length>1&&arguments[1]!==void 0)||arguments[1];var a=o.indexOf(e);return a<0?t?i.slice(i.indexOf(e)+1).find((function(e){return r(e)})):i.slice(0,i.indexOf(e)).reverse().find((function(e){return r(e)})):o[a+(t?1:-1)]}}}));g.tabbableGroups=g.containerGroups.filter((function(e){return e.tabbableNodes.length>0}));if(g.tabbableGroups.length<=0&&!k("fallbackFocus"))throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");if(g.containerGroups.find((function(e){return e.posTabIndexesFound}))&&g.containerGroups.length>1)throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.")};
/**
   * Gets the current activeElement. If it's a web-component and has open shadow-root
   * it will recursively search inside shadow roots for the "true" activeElement.
   *
   * @param {Document | ShadowRoot} el
   *
   * @returns {HTMLElement} The element that currently has the focus
   **/var E=function getActiveElement(e){var t=e.activeElement;if(t)return t.shadowRoot&&t.shadowRoot.activeElement!==null?E(t.shadowRoot):t};var _=function tryFocus(e){if(e!==false&&e!==E(document))if(e&&e.focus){e.focus({preventScroll:!!w.preventScroll});g.mostRecentlyFocusedNode=e;i(e)&&e.select()}else _(O())};var A=function getReturnFocusNode(e){var t=k("setReturnFocus",{params:[e]});return t||t!==false&&e};
/**
   * Finds the next node (in either direction) where focus should move according to a
   *  keyboard focus-in event.
   * @param {Object} params
   * @param {Node} [params.target] Known target __from which__ to navigate, if any.
   * @param {KeyboardEvent|FocusEvent} [params.event] Event to use if `target` isn't known (event
   *  will be used to determine the `target`). Ignored if `target` is specified.
   * @param {boolean} [params.isBackward] True if focus should move backward.
   * @returns {Node|undefined} The next node, or `undefined` if a next node couldn't be
   *  determined given the current state of the trap.
   */var D=function findNextNavNode(t){var a=t.target,o=t.event,i=t.isBackward,u=i!==void 0&&i;a=a||f(o);P();var c=null;if(g.tabbableGroups.length>0){var l=F(a,o);var v=l>=0?g.containerGroups[l]:void 0;if(l<0)c=u?g.tabbableGroups[g.tabbableGroups.length-1].lastTabbableNode:g.tabbableGroups[0].firstTabbableNode;else if(u){var d=g.tabbableGroups.findIndex((function(e){var t=e.firstTabbableNode;return a===t}));d<0&&(v.container===a||e(a,w.tabbableOptions)&&!r(a,w.tabbableOptions)&&!v.nextTabbableNode(a,false))&&(d=l);if(d>=0){var b=d===0?g.tabbableGroups.length-1:d-1;var p=g.tabbableGroups[b];c=n(a)>=0?p.lastTabbableNode:p.lastDomTabbableNode}else s(o)||(c=v.nextTabbableNode(a,false))}else{var y=g.tabbableGroups.findIndex((function(e){var t=e.lastTabbableNode;return a===t}));y<0&&(v.container===a||e(a,w.tabbableOptions)&&!r(a,w.tabbableOptions)&&!v.nextTabbableNode(a))&&(y=l);if(y>=0){var m=y===g.tabbableGroups.length-1?0:y+1;var h=g.tabbableGroups[m];c=n(a)>=0?h.firstTabbableNode:h.firstDomTabbableNode}else s(o)||(c=v.nextTabbableNode(a))}}else c=k("fallbackFocus");return c};var I=function checkPointerDown(e){var t=f(e);F(t,e)>=0||(d(w.clickOutsideDeactivates,e)?N.deactivate({returnFocus:w.returnFocusOnDeactivate}):d(w.allowOutsideClick,e)||e.preventDefault())};var S=function checkFocusIn(e){var t=f(e);var a=F(t,e)>=0;if(a||t instanceof Document)a&&(g.mostRecentlyFocusedNode=t);else{e.stopImmediatePropagation();var r;var o=true;if(g.mostRecentlyFocusedNode)if(n(g.mostRecentlyFocusedNode)>0){var i=F(g.mostRecentlyFocusedNode);var u=g.containerGroups[i].tabbableNodes;if(u.length>0){var s=u.findIndex((function(e){return e===g.mostRecentlyFocusedNode}));if(s>=0)if(w.isKeyForward(g.recentNavEvent)){if(s+1<u.length){r=u[s+1];o=false}}else if(s-1>=0){r=u[s-1];o=false}}}else g.containerGroups.some((function(e){return e.tabbableNodes.some((function(e){return n(e)>0}))}))||(o=false);else o=false;o&&(r=D({target:g.mostRecentlyFocusedNode,isBackward:w.isKeyBackward(g.recentNavEvent)}));_(r||(g.mostRecentlyFocusedNode||O()))}g.recentNavEvent=void 0};var G=function checkKeyNav(e){var t=arguments.length>1&&arguments[1]!==void 0&&arguments[1];g.recentNavEvent=e;var a=D({event:e,isBackward:t});if(a){s(e)&&e.preventDefault();_(a)}};var x=function checkTabKey(e){(w.isKeyForward(e)||w.isKeyBackward(e))&&G(e,w.isKeyBackward(e))};var j=function checkEscapeKey(e){if(u(e)&&d(w.escapeDeactivates,e)!==false){e.preventDefault();N.deactivate()}};var L=function checkClick(e){var t=f(e);if(!(F(t,e)>=0)&&!d(w.clickOutsideDeactivates,e)&&!d(w.allowOutsideClick,e)){e.preventDefault();e.stopImmediatePropagation()}};var R=function addListeners(){if(g.active){o.activateTrap(h,N);g.delayInitialFocusTimer=w.delayInitialFocus?v((function(){_(O())})):_(O());m.addEventListener("focusin",S,true);m.addEventListener("mousedown",I,{capture:true,passive:false});m.addEventListener("touchstart",I,{capture:true,passive:false});m.addEventListener("click",L,{capture:true,passive:false});m.addEventListener("keydown",x,{capture:true,passive:false});m.addEventListener("keydown",j);return N}};var K=function removeListeners(){if(g.active){m.removeEventListener("focusin",S,true);m.removeEventListener("mousedown",I,true);m.removeEventListener("touchstart",I,true);m.removeEventListener("click",L,true);m.removeEventListener("keydown",x,true);m.removeEventListener("keydown",j);return N}};var C=function checkDomRemoval(e){var t=e.some((function(e){var t=Array.from(e.removedNodes);return t.some((function(e){return e===g.mostRecentlyFocusedNode}))}));t&&_(O())};var B=typeof window!=="undefined"&&"MutationObserver"in window?new MutationObserver(C):void 0;var M=function updateObservedNodes(){if(B){B.disconnect();g.active&&!g.paused&&g.containers.map((function(e){B.observe(e,{subtree:true,childList:true})}))}};N={get active(){return g.active},get paused(){return g.paused},activate:function activate(e){if(g.active)return this;var t=T(e,"onActivate");var a=T(e,"onPostActivate");var r=T(e,"checkCanFocusTrap");r||P();g.active=true;g.paused=false;g.nodeFocusedBeforeActivation=m.activeElement;t===null||t===void 0||t();var n=function finishActivation(){r&&P();R();M();a===null||a===void 0||a()};if(r){r(g.containers.concat()).then(n,n);return this}n();return this},deactivate:function deactivate(e){if(!g.active)return this;var t=_objectSpread2({onDeactivate:w.onDeactivate,onPostDeactivate:w.onPostDeactivate,checkCanReturnFocus:w.checkCanReturnFocus},e);clearTimeout(g.delayInitialFocusTimer);g.delayInitialFocusTimer=void 0;K();g.active=false;g.paused=false;M();o.deactivateTrap(h,N);var a=T(t,"onDeactivate");var r=T(t,"onPostDeactivate");var n=T(t,"checkCanReturnFocus");var i=T(t,"returnFocus","returnFocusOnDeactivate");a===null||a===void 0||a();var u=function finishDeactivation(){v((function(){i&&_(A(g.nodeFocusedBeforeActivation));r===null||r===void 0||r()}))};if(i&&n){n(A(g.nodeFocusedBeforeActivation)).then(u,u);return this}u();return this},pause:function pause(e){if(!g.active)return this;g.manuallyPaused=true;return this._setPausedState(true,e)},unpause:function unpause(e){if(!g.active)return this;g.manuallyPaused=false;return h[h.length-1]!==this?this:this._setPausedState(false,e)},updateContainerElements:function updateContainerElements(e){var t=[].concat(e).filter(Boolean);g.containers=t.map((function(e){return typeof e==="string"?m.querySelector(e):e}));g.active&&P();M();return this}};Object.defineProperties(N,{_isManuallyPaused:{value:function value(){return g.manuallyPaused}},_setPausedState:{value:function value(e,t){if(g.paused===e)return this;g.paused=e;if(e){var a=T(t,"onPause");var r=T(t,"onPostPause");a===null||a===void 0||a();K();M();r===null||r===void 0||r()}else{var n=T(t,"onUnpause");var o=T(t,"onPostUnpause");n===null||n===void 0||n();P();R();M();o===null||o===void 0||o()}return this}}});N.updateContainerElements(p);return N};export{p as createFocusTrap};

